#!/usr/bin/env bash

# Cassandra-CPP Development Environment Setup Script
# This script sets up the complete development environment for Cassandra-CPP

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
REQUIRED_RUBY_VERSION="3.2.0"
REQUIRED_DOCKER_VERSION="20.10.0"
REQUIRED_DOCKER_COMPOSE_VERSION="2.0.0"

# Logging functions
log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

debug() {
    if [[ "${DEBUG:-}" == "1" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Version comparison function
version_gte() {
    printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

# System detection
detect_system() {
    log "Detecting system information..."
    
    case "$(uname -s)" in
        Linux*)     SYSTEM=Linux;;
        Darwin*)    SYSTEM=Mac;;
        CYGWIN*)    SYSTEM=Cygwin;;
        MINGW*)     SYSTEM=MinGw;;
        *)          SYSTEM="UNKNOWN:$(uname -s)"
    esac
    
    log "Detected system: $SYSTEM"
    
    if [[ "$SYSTEM" == "Linux" ]]; then
        if command_exists lsb_release; then
            DISTRO=$(lsb_release -si)
            DISTRO_VERSION=$(lsb_release -sr)
        elif [[ -f /etc/os-release ]]; then
            . /etc/os-release
            DISTRO=$NAME
            DISTRO_VERSION=$VERSION_ID
        fi
        log "Linux distribution: $DISTRO $DISTRO_VERSION"
    fi
}

# Check system dependencies
check_system_dependencies() {
    log "Checking system dependencies..."
    
    local missing_deps=()
    
    # Essential build tools
    if [[ "$SYSTEM" == "Linux" ]]; then
        local required_packages=(
            "build-essential"
            "cmake"
            "pkg-config"
            "git"
            "curl"
            "wget"
        )
        
        for package in "${required_packages[@]}"; do
            if ! dpkg -l | grep -q "^ii  $package "; then
                missing_deps+=("$package")
            fi
        done
        
        # Check for development libraries
        local required_libs=(
            "libuv1-dev"
            "libssl-dev"
            "zlib1g-dev"
            "libgmp-dev"
            "libffi-dev"
            "libyaml-dev"
            "libreadline-dev"
        )
        
        for lib in "${required_libs[@]}"; do
            if ! dpkg -l | grep -q "^ii  $lib "; then
                missing_deps+=("$lib")
            fi
        done
        
    elif [[ "$SYSTEM" == "Mac" ]]; then
        # Check for Homebrew
        if ! command_exists brew; then
            error "Homebrew is required on macOS. Please install it from https://brew.sh/"
            exit 1
        fi
        
        local required_packages=(
            "cmake"
            "pkg-config"
            "libuv"
            "openssl"
            "zlib"
        )
        
        for package in "${required_packages[@]}"; do
            if ! brew list "$package" >/dev/null 2>&1; then
                missing_deps+=("$package")
            fi
        done
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        warn "Missing system dependencies: ${missing_deps[*]}"
        
        if [[ "$SYSTEM" == "Linux" ]]; then
            log "Installing missing packages with apt..."
            sudo apt-get update
            sudo apt-get install -y "${missing_deps[@]}"
        elif [[ "$SYSTEM" == "Mac" ]]; then
            log "Installing missing packages with brew..."
            brew install "${missing_deps[@]}"
        fi
    else
        log "All system dependencies are satisfied"
    fi
}

# Check Ruby version
check_ruby() {
    log "Checking Ruby installation..."
    
    if ! command_exists ruby; then
        error "Ruby is not installed. Please install Ruby $REQUIRED_RUBY_VERSION or later."
        error "Consider using rbenv, rvm, or asdf for Ruby version management."
        exit 1
    fi
    
    local ruby_version
    ruby_version=$(ruby -v | cut -d' ' -f2)
    
    if version_gte "$ruby_version" "$REQUIRED_RUBY_VERSION"; then
        log "Ruby version $ruby_version is compatible (>= $REQUIRED_RUBY_VERSION)"
    else
        error "Ruby version $ruby_version is too old. Required: >= $REQUIRED_RUBY_VERSION"
        exit 1
    fi
    
    # Check bundler
    if ! command_exists bundle; then
        log "Installing bundler..."
        gem install bundler
    fi
    
    local bundler_version
    bundler_version=$(bundle -v | cut -d' ' -f3)
    log "Bundler version: $bundler_version"
}

# Check Docker
check_docker() {
    log "Checking Docker installation..."
    
    if ! command_exists docker; then
        error "Docker is not installed. Please install Docker $REQUIRED_DOCKER_VERSION or later."
        error "Visit https://docs.docker.com/get-docker/ for installation instructions."
        exit 1
    fi
    
    local docker_version
    docker_version=$(docker --version | cut -d' ' -f3 | tr -d ',')
    
    if version_gte "$docker_version" "$REQUIRED_DOCKER_VERSION"; then
        log "Docker version $docker_version is compatible (>= $REQUIRED_DOCKER_VERSION)"
    else
        warn "Docker version $docker_version might be too old. Recommended: >= $REQUIRED_DOCKER_VERSION"
    fi
    
    # Check Docker Compose
    if ! command_exists docker-compose && ! docker compose version >/dev/null 2>&1; then
        error "Docker Compose is not installed or not working."
        exit 1
    fi
    
    local compose_version
    if command_exists docker-compose; then
        compose_version=$(docker-compose --version | cut -d' ' -f3 | tr -d ',')
        COMPOSE_CMD="docker-compose"
    else
        compose_version=$(docker compose version --short)
        COMPOSE_CMD="docker compose"
    fi
    
    if version_gte "$compose_version" "$REQUIRED_DOCKER_COMPOSE_VERSION"; then
        log "Docker Compose version $compose_version is compatible (>= $REQUIRED_DOCKER_COMPOSE_VERSION)"
    else
        warn "Docker Compose version $compose_version might be too old. Recommended: >= $REQUIRED_DOCKER_COMPOSE_VERSION"
    fi
    
    # Check Docker daemon
    if ! docker info >/dev/null 2>&1; then
        error "Docker daemon is not running. Please start Docker and try again."
        exit 1
    fi
    
    log "Docker is ready"
}

# Install DataStax C++ Driver
install_cassandra_driver() {
    log "Checking DataStax C++ driver..."
    
    # Check if already installed
    if pkg-config --exists cassandra 2>/dev/null; then
        local installed_version
        installed_version=$(pkg-config --modversion cassandra)
        log "DataStax C++ driver v$installed_version is already installed"
        return 0
    fi
    
    log "Installing DataStax C++ driver..."
    
    local temp_dir
    temp_dir=$(mktemp -d)
    cd "$temp_dir"
    
    local driver_version="2.17.1"
    local driver_url="https://github.com/datastax/cpp-driver/archive/${driver_version}.tar.gz"
    
    log "Downloading driver version $driver_version..."
    wget "$driver_url" -O "cpp-driver-${driver_version}.tar.gz"
    tar -xzf "cpp-driver-${driver_version}.tar.gz"
    cd "cpp-driver-${driver_version}"
    
    mkdir build
    cd build
    
    log "Configuring build..."
    if [[ "$SYSTEM" == "Mac" ]]; then
        cmake .. \
            -DCASS_BUILD_STATIC=ON \
            -DCASS_BUILD_SHARED=ON \
            -DCASS_USE_STATIC_LIBS=ON \
            -DCASS_USE_ZLIB=ON \
            -DCASS_USE_OPENSSL=ON \
            -DOPENSSL_ROOT_DIR="$(brew --prefix openssl)"
    else
        cmake .. \
            -DCASS_BUILD_STATIC=ON \
            -DCASS_BUILD_SHARED=ON \
            -DCASS_USE_STATIC_LIBS=ON \
            -DCASS_USE_ZLIB=ON \
            -DCASS_USE_OPENSSL=ON
    fi
    
    log "Building driver..."
    local cpu_count
    if [[ "$SYSTEM" == "Mac" ]]; then
        cpu_count=$(sysctl -n hw.ncpu)
    else
        cpu_count=$(nproc)
    fi
    make -j"$cpu_count"
    
    log "Installing driver..."
    if [[ "$SYSTEM" == "Linux" ]]; then
        sudo make install
        sudo ldconfig
    else
        make install
    fi
    
    cd "$PROJECT_ROOT"
    rm -rf "$temp_dir"
    
    log "DataStax C++ driver installed successfully"
}

# Setup Ruby environment
setup_ruby_env() {
    log "Setting up Ruby environment..."
    
    cd "$PROJECT_ROOT"
    
    # Install gems
    log "Installing Ruby gems..."
    bundle config set --local deployment false
    bundle config set --local path 'vendor/bundle'
    bundle config set --local without 'production'
    bundle config set --local jobs 4
    bundle config set --local retry 3
    
    bundle install
    
    # Setup git hooks (if overcommit is available)
    if bundle exec overcommit --version >/dev/null 2>&1; then
        log "Setting up git hooks with overcommit..."
        bundle exec overcommit --install
        bundle exec overcommit --sign
    fi
    
    log "Ruby environment setup complete"
}

# Setup Docker environment
setup_docker_env() {
    log "Setting up Docker development environment..."
    
    cd "$PROJECT_ROOT"
    
    # Build development image
    log "Building development Docker image..."
    docker build -f Dockerfile.dev -t cassandra-cpp-dev .
    
    # Pull required images
    log "Pulling required Docker images..."
    docker pull cassandra:4.1
    docker pull redis:7-alpine
    
    # Create Docker networks and volumes
    log "Creating Docker resources..."
    docker network create cassandra-net 2>/dev/null || true
    
    log "Docker environment setup complete"
}

# Setup development tools
setup_dev_tools() {
    log "Setting up development tools..."
    
    cd "$PROJECT_ROOT"
    
    # Initialize Sorbet
    if bundle exec srb version >/dev/null 2>&1; then
        log "Initializing Sorbet..."
        bundle exec srb init 2>/dev/null || true
        
        # Generate RBI files
        log "Generating RBI files..."
        bundle exec tapioca init
        bundle exec tapioca gems
    fi
    
    # Setup RuboCop
    if [[ ! -f .rubocop.yml ]]; then
        log "Creating RuboCop configuration..."
        cat > .rubocop.yml << 'EOF'
require:
  - rubocop-performance
  - rubocop-rspec
  - rubocop-sorbet

AllCops:
  TargetRubyVersion: 3.2
  NewCops: enable
  Exclude:
    - 'vendor/**/*'
    - 'bin/**/*'
    - 'sorbet/**/*'

Style/Documentation:
  Enabled: false

Metrics/BlockLength:
  Exclude:
    - 'spec/**/*'
    - '*.gemspec'

Layout/LineLength:
  Max: 120
EOF
    fi
    
    # Create necessary directories
    mkdir -p tmp log coverage spec/support
    
    # Setup environment files
    if [[ ! -f .env.development ]]; then
        log "Creating development environment file..."
        cat > .env.development << 'EOF'
# Development environment configuration
CASSANDRA_HOSTS=localhost
CASSANDRA_PORT=9042
CASSANDRA_KEYSPACE=cassandra_cpp_development
RUBY_ENV=development
DEBUG=0
EOF
    fi
    
    if [[ ! -f .env.test ]]; then
        log "Creating test environment file..."
        cat > .env.test << 'EOF'
# Test environment configuration
CASSANDRA_HOSTS=localhost
CASSANDRA_PORT=9042
CASSANDRA_KEYSPACE=cassandra_cpp_test
RUBY_ENV=test
DEBUG=0
EOF
    fi
    
    log "Development tools setup complete"
}

# Start development services
start_services() {
    log "Starting development services..."
    
    cd "$PROJECT_ROOT"
    
    # Start Cassandra cluster
    log "Starting Cassandra cluster..."
    $COMPOSE_CMD up -d cassandra-1 cassandra-2
    
    # Wait for Cassandra to be ready
    log "Waiting for Cassandra to be ready..."
    local max_attempts=30
    local attempt=1
    
    while [[ $attempt -le $max_attempts ]]; do
        if docker exec cassandra-node-1 cqlsh -e "describe keyspaces" >/dev/null 2>&1; then
            log "Cassandra is ready!"
            break
        fi
        
        log "Attempt $attempt/$max_attempts: Waiting for Cassandra..."
        sleep 10
        ((attempt++))
    done
    
    if [[ $attempt -gt $max_attempts ]]; then
        error "Cassandra failed to start within expected time"
        exit 1
    fi
    
    # Create development keyspaces
    log "Creating development keyspaces..."
    docker exec cassandra-node-1 cqlsh -e "
        CREATE KEYSPACE IF NOT EXISTS cassandra_cpp_development
        WITH REPLICATION = {
            'class': 'SimpleStrategy',
            'replication_factor': 2
        };
        
        CREATE KEYSPACE IF NOT EXISTS cassandra_cpp_test
        WITH REPLICATION = {
            'class': 'SimpleStrategy',
            'replication_factor': 2
        };
    "
    
    log "Development services started successfully"
}

# Build C++ extension
build_cpp_extension() {
    log "Building C++ extension..."
    
    cd "$PROJECT_ROOT"
    
    # Build the extension
    log "Compiling native extension..."
    cd ext/cassandra_cpp
    
    if ruby extconf.rb; then
        log "Configuration successful"
    else
        error "Failed to configure C++ extension"
        exit 1
    fi
    
    if make; then
        log "C++ extension compiled successfully"
    else
        error "Failed to compile C++ extension"
        exit 1
    fi
    
    cd "$PROJECT_ROOT"
    
    # Install the extension
    log "Installing C++ extension..."
    if bundle exec rake compile; then
        log "C++ extension installed successfully"
    else
        warn "Failed to install C++ extension via rake - trying manual installation"
        
        # Manual installation fallback
        mkdir -p lib/cassandra_cpp/
        cp ext/cassandra_cpp/cassandra_cpp.so lib/cassandra_cpp/ 2>/dev/null || \
        cp ext/cassandra_cpp/cassandra_cpp.bundle lib/cassandra_cpp/ 2>/dev/null || \
        warn "Could not copy extension library - check compilation"
    fi
}

# Run initial tests
run_initial_tests() {
    log "Running initial tests to verify setup..."
    
    cd "$PROJECT_ROOT"
    
    # Set test environment
    export CASSANDRA_HOSTS=localhost
    export CASSANDRA_PORT=9042
    export CASSANDRA_KEYSPACE=cassandra_cpp_test
    
    # Test C++ extension loading
    log "Testing C++ extension loading..."
    if ruby -e "require './lib/cassandra_cpp'; puts 'C++ extension loaded successfully'" 2>/dev/null; then
        log "C++ extension test passed"
    else
        warn "C++ extension test failed - checking compilation"
        build_cpp_extension
        
        # Retry after building
        if ruby -e "require './lib/cassandra_cpp'; puts 'C++ extension loaded successfully'" 2>/dev/null; then
            log "C++ extension test passed after rebuild"
        else
            warn "C++ extension still not loading - manual intervention may be needed"
        fi
    fi
    
    # Run basic tests if they exist
    if [[ -f spec/spec_helper.rb ]]; then
        log "Running basic test suite..."
        if bundle exec rspec spec/ --tag ~integration; then
            log "Basic tests passed"
        else
            warn "Some tests failed - this might be expected for initial setup"
        fi
    fi
}

# Generate development documentation
generate_docs() {
    log "Generating development documentation..."
    
    cd "$PROJECT_ROOT"
    
    if bundle exec yard --version >/dev/null 2>&1; then
        bundle exec yard doc
        log "Documentation generated in doc/ directory"
    fi
}

# Main setup function
main() {
    log "Starting Cassandra-CPP development environment setup..."
    log "Project root: $PROJECT_ROOT"
    
    # Change to project directory
    cd "$PROJECT_ROOT"
    
    # Run setup steps
    detect_system
    check_system_dependencies
    check_ruby
    check_docker
    install_cassandra_driver
    setup_ruby_env
    build_cpp_extension
    setup_docker_env
    setup_dev_tools
    
    if [[ "${SKIP_SERVICES:-}" != "1" ]]; then
        start_services
    fi
    
    if [[ "${SKIP_TESTS:-}" != "1" ]]; then
        run_initial_tests
    fi
    
    generate_docs
    
    log "🎉 Setup complete!"
    log ""
    log "Next steps:"
    log "  1. Test C++ extension: ruby -e \"require './lib/cassandra_cpp'; puts 'Extension loaded!'\""
    log "  2. Run tests: bundle exec rspec"
    log "  3. Start development: $COMPOSE_CMD up cassandra-cpp-dev"
    log "  4. Access development shell: docker exec -it cassandra-cpp-dev bash"
    log "  5. View documentation: open doc/index.html"
    log ""
    log "Useful commands:"
    log "  • Start services: $COMPOSE_CMD up -d"
    log "  • Stop services: $COMPOSE_CMD down"
    log "  • View logs: $COMPOSE_CMD logs -f"
    log "  • Run tests: bundle exec rspec"
    log "  • Rebuild extension: cd ext/cassandra_cpp && ruby extconf.rb && make"
    log "  • Run linter: bundle exec rubocop"
    log "  • Type check: bundle exec srb tc"
    log ""
    log "C++ Extension Info:"
    log "  • Extension source: ext/cassandra_cpp/cassandra_cpp.cpp"
    log "  • Build config: ext/cassandra_cpp/extconf.rb"
    log "  • DataStax driver: $(pkg-config --modversion cassandra 2>/dev/null || echo 'not found via pkg-config')"
    log ""
    log "Happy coding! 🚀"
}

# Handle script arguments
case "${1:-}" in
    --help|-h)
        echo "Cassandra-CPP Development Environment Setup"
        echo ""
        echo "Usage: $0 [options]"
        echo ""
        echo "Options:"
        echo "  --help, -h          Show this help message"
        echo "  --debug             Enable debug output"
        echo "  --skip-services     Skip starting Docker services"
        echo "  --skip-tests        Skip running initial tests"
        echo ""
        exit 0
        ;;
    --debug)
        export DEBUG=1
        shift
        ;;
    --skip-services)
        SKIP_SERVICES=1
        shift
        ;;
    --skip-tests)
        SKIP_TESTS=1
        shift
        ;;
esac

# Run main function
main "$@"